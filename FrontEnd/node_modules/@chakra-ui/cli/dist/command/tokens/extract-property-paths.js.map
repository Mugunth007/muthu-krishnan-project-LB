{"version":3,"sources":["../../../src/command/tokens/extract-property-paths.ts"],"names":["AutoCompleteStringType","wrapWithQuotes","value","printUnionType","values","strict","length","map","concat","join","printUnionMap","unions","Object","entries","sort","a","b","localeCompare","targetKey","union","extractPropertyPaths","target","maxDepth","Array","isArray","reduce","allPropertyPaths","key","forEach","childKey","push"],"mappings":";;;;;;AAAA;;AAEA,IAAMA,sBAAsB,GAAG,eAA/B;;AAEA,SAASC,cAAT,CAAwBC,KAAxB,EAAwC;AACtC,gBAAWA,KAAX;AACD;;AAED,SAASC,cAAT,CAAwBC,MAAxB,EAA0CC,MAA1C,EAA0D;AAAA,MAAhBA,MAAgB;AAAhBA,IAAAA,MAAgB,GAAP,KAAO;AAAA;;AACxD,MAAI,CAACD,MAAM,CAACE,MAAZ,EAAoB;AAClB,WAAOD,MAAM,GAAG,OAAH,GAAaL,sBAA1B;AACD;;AAED,SAAOI,MAAM,CACVG,GADI,CACAN,cADA,EAEJO,MAFI,CAEGH,MAAM,GAAG,EAAH,GAAQ,CAACL,sBAAD,CAFjB,EAGJS,IAHI,CAGC,KAHD,CAAP;AAID;AAED;AACA;AACA;AACA;;;AACO,SAASC,aAAT,CACLC,MADK,EAELN,MAFK,EAGL;AAAA,MADAA,MACA;AADAA,IAAAA,MACA,GADS,KACT;AAAA;;AACA,SAAOO,MAAM,CAACC,OAAP,CAAeF,MAAf,EACJG,IADI,CACC;AAAA,QAAEC,CAAF;AAAA,QAAOC,CAAP;AAAA,WAAcD,CAAC,CAACE,aAAF,CAAgBD,CAAhB,CAAd;AAAA,GADD,EAEJT,GAFI,CAGH;AAAA,QAAEW,SAAF;AAAA,QAAaC,KAAb;AAAA,WAA2BD,SAA3B,UAAyCf,cAAc,CAACgB,KAAD,EAAQd,MAAR,CAAvD;AAAA,GAHG,EAKJI,IALI,CAKC,IALD,CAAP;AAMD;AAED;AACA;AACA;;;AACO,SAASW,oBAAT,CAA8BC,MAA9B,EAA+CC,QAA/C,EAA6D;AAAA,MAAdA,QAAc;AAAdA,IAAAA,QAAc,GAAH,CAAG;AAAA;;AAClE,MAAK,CAAC,qBAASD,MAAT,CAAD,IAAqB,CAACE,KAAK,CAACC,OAAN,CAAcH,MAAd,CAAvB,IAAiD,CAACC,QAAtD,EAAgE;AAC9D,WAAO,EAAP;AACD;;AAED,SAAOV,MAAM,CAACC,OAAP,CAAeQ,MAAf,EAAuBI,MAAvB,CAA8B,UAACC,gBAAD,SAAoC;AAAA,QAAhBC,GAAgB;AAAA,QAAXzB,KAAW;;AACvE,QAAI,qBAASA,KAAT,CAAJ,EAAqB;AACnBkB,MAAAA,oBAAoB,CAAClB,KAAD,EAAQoB,QAAQ,GAAG,CAAnB,CAApB,CAA0CM,OAA1C,CAAkD,UAACC,QAAD;AAAA,eAChD;AACAH,UAAAA,gBAAgB,CAACI,IAAjB,CAAyBH,GAAzB,SAAgCE,QAAhC;AAFgD;AAAA,OAAlD;AAID,KALD,MAKO;AACL;AACAH,MAAAA,gBAAgB,CAACI,IAAjB,CAAsBH,GAAtB;AACD;;AAED,WAAOD,gBAAP;AACD,GAZM,EAYJ,EAZI,CAAP;AAaD","sourcesContent":["import { isObject } from \"@chakra-ui/utils\"\n\nconst AutoCompleteStringType = \"(string & {})\"\n\nfunction wrapWithQuotes(value: unknown) {\n  return `\"${value}\"`\n}\n\nfunction printUnionType(values: string[], strict = false) {\n  if (!values.length) {\n    return strict ? \"never\" : AutoCompleteStringType\n  }\n\n  return values\n    .map(wrapWithQuotes)\n    .concat(strict ? [] : [AutoCompleteStringType])\n    .join(\" | \")\n}\n\n/**\n * @example\n * { colors: ['red.500', 'green.500'] } => `colors: \"red.500\" | \"green.500\"`\n */\nexport function printUnionMap(\n  unions: Record<string, string[]>,\n  strict = false,\n) {\n  return Object.entries(unions)\n    .sort(([a], [b]) => a.localeCompare(b))\n    .map(\n      ([targetKey, union]) => `${targetKey}: ${printUnionType(union, strict)};`,\n    )\n    .join(\"\\n\")\n}\n\n/**\n * Extract recursively all property paths with a max depth\n */\nexport function extractPropertyPaths(target: unknown, maxDepth = 3) {\n  if ((!isObject(target) && !Array.isArray(target)) || !maxDepth) {\n    return []\n  }\n\n  return Object.entries(target).reduce((allPropertyPaths, [key, value]) => {\n    if (isObject(value)) {\n      extractPropertyPaths(value, maxDepth - 1).forEach((childKey) =>\n        // e.g. gray.500\n        allPropertyPaths.push(`${key}.${childKey}`),\n      )\n    } else {\n      // e.g. transparent\n      allPropertyPaths.push(key)\n    }\n\n    return allPropertyPaths\n  }, [] as string[])\n}\n"],"file":"extract-property-paths.js"}